Chapter 13
Interrupts
Introduction
Interrupts are pervasive within and between processors in the PS and PL. The system
interrupts communicate status, events, requests, and errors within the heterogeneous
processing system.
The platform management unit (PMU) and configuration security unit (CSU) have local
interrupt controllers. The PMU interrupt controller is described in Chapter 6, Platform
Management Unit. It includes the CPU and external interrupt controllers. The CSU interrupt
controller is a closed system managed by the CSR ROM code.
The RPU uses the Arm PL-390 generic interrupt controller that is compliant to the GICv1
architecture specification. The APU MPCore uses the Arm GIC-400 generic interrupt
controller and is compliant to the GICv2 architecture specification. The GIC manages the
software-generated interrupts (SGI), each CPU’s private peripheral interrupts (PPI), and the
shared peripheral interrupts (SPI).
The PMU uses the GIC proxy interrupts when the RPU and APU cannot service an interrupt
because the processor is powered down. The GIC proxy is an AMD architecture for the PMU
external interrupt controller and is controlled by the PMU.
The register documentation for the three system interrupt controllers is listed here.
• RPU GIC: PrimeCell Generic Interrupt Controller (PL390), DDI 0416B, r0p0.
• APU GIC: CoreLink GIC-400 Generic Interrupt Controller, DDI 0471B, r0p1.
• GIC Proxy: Zynq UltraScale+ MPSoC Register Reference (UG1087) [Ref 4], LPD_SLCR
register set.
There are 148 system interrupts that connect to each GIC, the GIC proxy interrupt structure,
and the PL fabric. The system interrupts are normally handled by the RPU or APU MPCores.
The user firmware in the PMU can process system interrupts in the absence of an RPU or
APU. The CSU does not connect to the system interrupts.
Note: An inter-processor interrupt (IPI) channel is associated with a processor target to allow other
processors in the heterogeneous processing system to send it messages and receive a response in
return. The IPI target processor receives an interrupt from another processor and accesses the
message buffer with a prearrange communications protocol. The IPI channels can target the system
Send FeedbackZynq UltraScale+ Device TRM 299
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
processors: APU MPCore, RPU core 0, RPU core 1, four channels to processor(s) in the PL, and four
private channels to the PMU.
Note: The PMU has four IPI interrupts. PMU_0 interrupt is assigned by the PMU firmware to
transition the PMU to sleep mode.
GIC Features
Both GICs have many similar features:
• Multiprocessor environment for the MPCore.
• Arbitrate system interrupts to the CPU cores.
• Software generated interrupt:
° Mechanism for one CPU to interrupt another CPU within an MPCore.
• Private peripheral interrupts IRQ/FIQ from PL.
• Shared peripheral interrupt:
° Manage system interrupts from system elements.
RPU-specific GIC Features
The RPU GIC has some unique features:
• GICv1 programming model.
• Security extensions.
APU-specific GIC Features
The APU GIC includes most of the same features as in the RPU GIC with the addition of
security and virtualization:
• GICv2 programming model.
• Security extensions.
• Virtualization extensions.
• Interrupt groups:
° Group 0 interrupts cause either IRQ or IFQ signaling.
° Group 1 interrupts use IRQ signaling.
° Unified scheme to handle priority.
° Optional register lockdown on some group 0 interrupts.
• CPU private registers have restricted accessed on the AXI interconnect.
Send FeedbackZynq UltraScale+ Device TRM 300
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
GIC Proxy Interrupts
The GIC proxy manages all the system interrupts connected to the GIC SPI interrupts. These
system interrupts set bits in the GICP{0:4}_IRQ_STATUS registers. After the masking
registers, the bit in each register is OR’ed together to set bits in another status register that
is OR’ed together to generate a single interrupt signal to the PMU external interrupt
controller.
The GIC proxy interrupts are used by the PMU in a fall-back mode to handle system
interrupts that cannot be managed by the application processors.
System Interrupts
The system interrupts are generated by many system elements and broadcast to the GICs,
the PMU via the GIC proxy (GICPx_IRQ registers), and to output signals in the PL. The system
interrupts are listed in Table 13-1. The table lists the IRQ numbers for the RPU and APU
interrupt controllers, as well as the GIC proxy bit assignments.
Table 13-1: System Interrupts
IRQ Name IRQ Number
(GIC) IDCICR(4) Bits Required
Type
GICPx_IRQ Bits
(GIC Proxy) Description
RPU0_Perf_Mon
40 2 [17:16] High level
GICP0 [8] RPU0 performance
monitor
(ARM_PMU)(1).
RPU1_Perf_Mon
41 2 [19:18] High level
GICP0 [9] RPU1 performance
monitor
(ARM_PMU)(1).
OCM
42 2 [21:20] High level GICP0 [10] OCM CE and UE ECC
errors.
LPD_APB
43 2 [23:22] High level GICP0 [11] OR of all APB slave
interface errors in LPD.
RPU0_ECC
44 2 [25:24] High level
GICP0 [12] RPU0 errors
combined: FPU,
memory ECC, and APB
access.
RPU1_ECC
45 2 [27:26] High level
GICP0 [13] RPU1 CE errors
combined: FPU,
memory, ECC, and APB
access.
NAND
46 2 [29:28] High level GICP0 [14] NAND memory
controller.
QSPI 47 2 [31:30] High level GICP0 [15] Quad-SPI controller.
GPIO 48 3 [1:0] High level GICP0 [16] GPIO controller.
I2C0 49 3 [3:2] High level GICP0 [17] I2C0 controller.
Send FeedbackZynq UltraScale+ Device TRM 301
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
I2C1 50 3 [5:4] High level GICP0 [18] I2C1 controller.
SPI0 51 3 [7:6] High level GICP0 [19] SPI0 controller.
SPI1 52 3 [9:8] High level GICP0 [20] SPI1 controller.
UART0 53 3 [11:10] High level GICP0 [21] UART 0 controller.
UART1 54 3 [13:12] High level GICP0 [22] UART 1 controller.
CAN0 55 3 [15:14] High level GICP0 [23] CAN 0 controller.
CAN1 56 3 [17:16] High level GICP0 [24] CAN 1 controller.
LPD_APM
57 3 [19:18] High level GICP0 [25] OR of the LPD and
OCM APM interrupts.
RTC_Alarm 58 3 [21:20] High level GICP0 [26] RTC alarm interrupt.
RTC_Seconds 59 3 [23:22] High level GICP0 [27] RTC seconds interrupt.
ClkMon 60 3 [25:24] High level GICP0 [28] Clock monitor in LPD.
IPI_Ch7
61 3 [27:26] High level GICP0 [29] IPIs targeting channel
7.
IPI_Ch8
62 3 [29:28] High level GICP0 [30] IPIs targeting channel
8.
IPI_Ch9
63 3 [31:30] High level GICP0 [31] IPIs targeting channel
9.
IPI_Ch10
64 4 [1:0] High level GICP1 [0] IPIs targeting channel
10.
IPI_Ch1
65 4 [3:2] High level GICP1 [1] IPIs targeting channel
1.
IPI_Ch2
66 4 [5:4] High level GICP1 [2] IPIs targeting channel
2.
IPI_Ch0
67 4 [7:6] High level GICP1 [3] IPIs targeting channel
0.
TTC0 68:70 4 [13:8] High level GICP1 [4:6] Triple-timer counter 0.
TTC1 71:73 4 [19:14] High level GICP1 [7:9] Triple-timer counter 1.
TTC2 74:76 4 [25:20] High level GICP1 [10:12] Triple-timer counter 2.
TTC3 77:79 4 [31:26] High level GICP1 [13:15] Triple-timer counter 3.
SDIO0 80 5 [1:0] High level GICP1 [16] SDIO 0 controller.
SDIO1 81 5 [3:2] High level GICP1 [17] SDIO 1 controller.
SDIO0_Wakeup
82 5 [5:4] High level GICP1 [18] SDIO 0 wake-up
interrupt.
SDIO1_Wakeup
83 5 [7:6] High level GICP1 [19] SDIO 1 wake-up
interrupt.
Table 13-1: System Interrupts (Cont’d)
IRQ Name IRQ Number
(GIC) IDCICR(4) Bits Required
Type
GICPx_IRQ Bits
(GIC Proxy) Description
Send FeedbackZynq UltraScale+ Device TRM 302
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
LPD_SWDT
84 5 [9:8] High level
GICP1 [20] LPD watchdog timer
(wdt0). Edge sensitive
trigger.(2)
CSU_SWDT
85 5 [11:10] High level
GICP1 [21] CSU and PMU
watchdog timer. Edge
sensitive trigger.(2)
LPD_ATB
86 5 I [13:12] High level GICP1 [22] OR of all ATB timeout
errors in LPD.
AIB
87 5 [15:14] High level GICP1 [23] OR of all AIB errors on
AXI and APB.
SysMon
88 5 [17:16] High level GICP1 [24] OR of all system
monitor interrupts.
GEM0 89 5 [19:18] High level GICP1 [25] Ethernet 0 controller.
GEM0_Wakeup
90 5 [21:20] High level GICP1 [26] Ethernet 0 wake-up
interrupt.
GEM1 91 5 [23:22] High level GICP1 [27] Ethernet 1 controller.
GEM1_Wakeup
92 5 [25:24] High level GICP1 [28] Ethernet 1 wake-up
interrupt.
GEM2 93 5 [27:26] High level GICP1 [29] Ethernet 2 interrupt.
GEM2_Wakeup
94 5 [29:28] High level GICP1 [30] Ethernet 2 wake-up
interrupt.
GEM3 95 5 [31:30] High level GICP1 [31] Ethernet 3 controller.
GEM3_Wakeup
96 6 [1:0] High level GICP2 [0] Ethernet 3 wake-up
interrupt.
USB0_Endpoint
97:100 6 [9:2] High level
GICP2 [1:4] USB 0 bulk transfer,
isochronous transfer,
controller interrupt,
control transfer.
USB0_OTG 101 6 [11:10] High level GICP2 [5] USB 0 OTG mode.
USB1_Endpoint
102:105 6 [19:12] High level
GICP2 [6:9] USB 1 bulk transfer,
isochronous transfer,
controller interrupt,
control transfer.
USB1_OTG 106 6 [21:20] High level GICP2 [10] USB 1 OTG mode.
USB0_Wakeup
107 6 [23:22] High level GICP2 [11] USB 0 controller to
wake-up PMU.
USB1_Wakeup
108 6 [25:24] High level GICP2 [12] USB 1 controller to
wake-up PMU.
LPD_DMA
109:116 6, 7 [31:26],
[9:0] High level GICP2 [13:20] Eight LPD DMA
channels 0 to 7.
Table 13-1: System Interrupts (Cont’d)
IRQ Name IRQ Number
(GIC) IDCICR(4) Bits Required
Type
GICPx_IRQ Bits
(GIC Proxy) Description
Send FeedbackZynq UltraScale+ Device TRM 303
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
CSU
117 7 [11:10] High level GICP2 [21] Configuration and
security unit.
CSU_DMA 118 7 [13:12] High level GICP2 [22] CSU DMA controller.
eFuse 119 7 [15:14] High level GICP2 [23] eFuse interrupt.
LPD_XMPU_XPPU
120 7 [17:16] High level
GICP2 [24] OCM XMPU and XPPU
protection units in
LPD.
PL_PS_Group0
121:128 7, 8 [31:18],
[1:0]
Rising
edge/high
level
GICP2 [25:31]
GICP3[0]
PL to PS interrupt
signals 0 to 7.(3)
Reserved
129:135 8 [15:2] High level GICP3 [1:7] Seven reserved
interrupts.
PL_PS_Group1
136:143 8 [31:16]
Rising
edge/high
level
GICP3 [8:15] PL to PS interrupt
signals 8 to 15.(3)
DDR
144 9 [1:0] High level GICP3 [16] DDR memory
controller.
FPD_SWDT
145 9 [3:2] High level
GICP3 [17] FPD system watchdog
timer (wdt1). Edge
sensitive trigger.(2)
PCIe_MSI0
146 9 [5:4] High level GICP3 [18] PCIe MSI vectors 0 to
31.
PCIe_MSI1
147 9 [7:6] High level GICP3 [19] PCIe MSI vectors 32 to
63.
PCIe_INTx
148 9 [9:8] High level
GICP3 [20] PCIe legacy: OR of INT
A, B, C, and D
interrupts.
PCIe_DMA 149 9 [11:10] High level GICP3 [21] PCIe_DMA controller.
PCIe_MSC 150 9 [13:12] High level GICP3 [22] PCIe_MSC controller.
DisplayPort 151 9 [15:14] High level GICP3 [23] DisplayPort controller.
FPD_APB
152 9 [17:16] High level GICP3 [24] OR of all APB slave
interface errors in FPD.
FPD_ATB
153 9 [19:18] High level GICP3 [25] OR of all ATB timeout
errors in FPD.
DPDMA
154 9 [21:20] High level GICP3 [26] DisplayPort DMA
controller.
FPD_APM
155 9 [23:22] High level GICP3 [27] OR of the CCI and DDR
APM interrupts.
FPD_DMA
156:163 9, 10 31:24],
[7:0] High level GICP3 [28:31]
GICP4 [0:3]
Eight FPD DMA
channels 0 to 7.
Table 13-1: System Interrupts (Cont’d)
IRQ Name IRQ Number
(GIC) IDCICR(4) Bits Required
Type
GICPx_IRQ Bits
(GIC Proxy) Description
Send FeedbackZynq UltraScale+ Device TRM 304
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
GPU
164 10 [9:8] High level GICP4 [4] OR of all GPU
interrupts.
SATA 165 10 [11:10] High level GICP4 [5] SATA controller.
FPD_XMPU
166 10 [13:12] High level
GICP4 [6] FPD and DDR XMPU
protection units in
FPD.
APU_VCPUMNT
167:170 10 [21:14] High level
GICP4 [7:10] Virtual processor
interface
maintenance.
CPU_CTI
171:174 10 [29:22] High level
GICP4 [11:14] CoreSight
cross-trigger
interface.
APU{0:3}_Perf_M
on 175:178 10, 11 [31:30],
[5:0] High level
GICP4 [15:18] APU{0:3} performance
monitors
(ARM_PMU)(1).
APU{0:3}_Comm
179:182 11 [13:6] High level GICP4 [19:22] Communications from
APU cores 0 to 3.
L2_Cache
183 11 [15:14] High level
GICP4 [23] L2 cache
uncorrectable ECC
error.
APU_ExtError
184 11 [17:16] High level
GICP4 [24] APU AXI transaction
with write error
response.
APU_RegError
185 11 [19:18] High level GICP4 [25] APU register access
address decode error.
CCI
186 11 [21:20] High level GICP4 [26] Cache coherent
interconnect unit.
SMMU
187 11 [23:22] High level GICP4 [27] System memory
management unit.
Notes:
1. The ARM_PMU is a performance monitor unit developed by Arm and is different from the platform management unit (PMU)
developed by AMD.
2. The system watchdog timers produce an interrupt pulse of at least four clock periods, which are programmable using the
x_SWDT.MODE [IRQLN] bit field. The four clock pulse length is sufficiently long enough for normal situations. The GIC
interrupt controllers must be programmed for edge sensitivity.
3. The minimum interrupt pulse width for detection is four clock periods of the GIC, which is normally a 100 MHz clock resulting
in a minimum 40 ns pulse width. The signal synchronizers might detect a shorter pulse, but it is not guaranteed. Glitches
should be avoided.
4. The configuration registers provided by the GIC distributor are mentioned under IDCICR as defined by Arm. For more details
refer “Distributor Register Description” in Chapter 3 of the ARM Primecell Generic Interrupt Controller PL390 Technical
Reference Manual r0p0 document number DDI0416B.
Table 13-1: System Interrupts (Cont’d)
IRQ Name IRQ Number
(GIC) IDCICR(4) Bits Required
Type
GICPx_IRQ Bits
(GIC Proxy) Description
Send FeedbackZynq UltraScale+ Device TRM 305
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
GIC Interrupt System Architecture
The system interrupt architecture includes GIC interrupt controllers for both MPCores, the
GIC proxy interrupt unit for the PMU, and the IPI interrupts for system-level processor
communications.
Interrupt Block Diagram
Figure 13-1 shows the block diagram of the processor interrupts. The shared peripheral
interrupts are generated from various subsystems that include the I/O peripherals in the PS
and logic in the PL. The PCIe MSI are handled by the controller for PCIe by decoding the MSI
into a bit-vector and then asserting a sideband interrupt. To guarantee PCIe ordering, the
controller for PCIe must wait for the completion of previously outstanding (inbound) writes
before asserted an MSI interrupt. Also, the controller for PCIe must ensure that the MSI
buffer, which holds the MSI information after asserting interrupt to CPU, does not end up
stalling the PCIe inbound traffic (which can cause deadlock).
X-Ref Target - Figure 13-1
Figure 13-1: GIC Interrupts Block Diagram
Cortex-A53 MPCore
CPU0 CPUn
CPU0 I/F VCPU0 I/F CPU0 I/F VCPUn I/F
Distributor
RPU Cores
CPU0 CPU1
GIC (PL390)
CPU0 I/F CPU1 I/F
Distributor
niRQ0/nFIQ0
nViRQ/nVFIQ
niRQ0/nFIQ0 niRQ1/nFIQ1
Interrupt Source Blocks
(e.g., VCU, GPU,
DisplayPort)
PCIe
Top Level IPI
PCIe Inbound
To Interconnect
To PMU
To PL
To PMU
To PMU
MSI
Legacy IRQ/FiQ per CPU
From PL
APU
GIC-400
X15327-092816
Send FeedbackZynq UltraScale+ Device TRM 306
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
RPU GIC Interrupt Controller
There are two interfaces between the RPU MPCore and the RPU GIC.
• Distributor interface is used to assign the interrupts to each of the Cortex-R5F MPCore
processors.
• CPU interface with a separate set of 4 KB memory-mapped registers for each CPU. This
provides protection against unwanted accesses by one CPU to interrupts that are
assigned to the other.
The APU MPCores processors access the RPU_GIC interrupt controller (Figure 13-2) through
their peripheral interface. The low-latency peripheral interfaces are really designed for
strongly ordered or device type accesses, which are restrictive by nature. Memory that is
marked as strongly ordered or device type is typically sensitive to the number of reads or
writes performed. Because of this, instructions that access strongly ordered or device
memory are never abandoned when they have started accessing memory. These
instructions always complete either all or none of their memory accesses. The same is true
of all accesses to the low-latency peripheral port, regardless of the memory type.
X-Ref Target - Figure 13-2
Figure 13-2: RPU Interrupt Controller Block Diagram
nIRQ
CPU 0
Distributor
SGI Distributor
Interrupt Controller Distributor (ICD)
Shared
Peripheral
Interrupts (SPI)
Softwre
Generated
Interrupts (SGI)
Software
Generated
Interrupts (SGI)
nFIQ nIRQ
nFIQ CPU 0
Interface
nIRQ
nFIQ
CPU 0
CPU 1
IOP PL
nIRQ
CPU 1
Distributor
nFIQ
nIRQ
nFIQ CPU 1
Interface
nIRQ
nFIQ
X15328-021517
Send FeedbackZynq UltraScale+ Device TRM 307
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
Software Generated Interrupts
Each CPU can interrupt itself, the other CPU, or both CPUs within the MPCore using a
software generated interrupt (SGI). There are 16 software generated interrupts. An SGI is
generated by writing the SGI interrupt number to the PL390.enable_sgi_control (ICDSGIR)
register and specifying the target CPU(s). This write occurs through the CPU's own private
bus. Each CPU has its own set of SGI registers to generate one or more of the 16 software
generated interrupts. The interrupts are cleared by reading the interrupt acknowledge
PL390.control_n_int_ack_n (ICCIAR) register or writing to the corresponding bits of the
interrupt clear-pending PL390.enable_sqi_pending (ICDICPR) register.
All SGIs are edge triggered. The sensitivity types for SGIs are fixed and cannot be changed;
the control register is read-only, because it specifies the sensitivity types of all the 16 SGIs.
Shared Peripheral Interrupts
A group of approximately 160 shared peripheral interrupts (SPIs) from various modules can
be routed to one or both of the CPUs or the PL. The interrupt controller manages the
prioritization and reception of these interrupts for the CPUs.
SPI Interrupt Sensitivity
The shared peripheral interrupts (SPI) can be targeted to any number of CPUs, but only one
CPU handles the interrupt. If an interrupt is targeted to both CPUs and they respond to the
GIC at the same time, the MPCore ensures that only one of the CPUs reads the active
interrupt ID#. The other CPU receives the spurious (ID 1023 or 1022) interrupt or the next
pending interrupt, depending on the timing.
Except for IRQ (121) through IRQ(128) and IRQ (136) through IRQ(143), which are the
interrupts from the PL, all interrupt sensitivity types are fixed by the requesting sources and
cannot be changed. The GIC must be programmed to accommodate this. The BootROM
does not program these registers; therefore the SDK device drivers must program the GIC
to accommodate these sensitivity types.
For an interrupt of level sensitivity type, the requesting source must provide a mechanism
for the interrupt handler to clear the interrupt after the interrupt has been acknowledged.
This requirement applies to any IRQ-F2P[n] (from PL) with a high-level sensitivity type.
For an interrupt of rising edge sensitivity, the requesting source must provide a pulse wide
that is large enough for the GIC to catch. This is normally at least two CPU_2x3x periods.
This requirement applies to any IRQ-F2P[n] (from PL) with a rising-edge sensitivity type. See
Answer Record 69390 for more information.
The sensitivity control for each interrupt has a 2-bit field that specifies sensitivity type and
handling model.
Send FeedbackZynq UltraScale+ Device TRM 308
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
Interrupt Prioritization
All of the SGI and SPI interrupt requests are assigned a unique ID number. The controller
uses the ID number to arbitrate. The interrupt distributor holds the list of pending
interrupts for each CPU and then selects the highest priority interrupt before issuing it to
the CPU interface. Interrupts of equal priority are resolved by selecting the lowest ID.
The prioritization logic is physically duplicated to enable the simultaneous selection of the
highest priority interrupt for each CPU. The interrupt distributor holds the central list of
interrupts, processors, and activation information, and is responsible for triggering
software interrupts to the CPUs.
SGI and PPI distributor registers are banked to provide a separate copy for each CPU. The
interrupt controller ensures that an interrupt targeting more than one CPU can only be
handled by one CPU at a time.
The interrupt distributor transmits to the CPU interfaces the highest pending interrupt. It
receives back the information that the interrupt is acknowledged and can now change the
status of the corresponding interrupt. Only the CPU that acknowledges the interrupt can
end that interrupt.
APU GIC Interrupt Controller
The APU uses an external GICv2 controller as a central resource to support and manage
interrupts. There are peripheral interrupts, software generated interrupts, and virtual
interrupts.
Peripheral Interrupts
Peripheral interrupts are asserted by a signal to the GIC. The GIC architecture defines the
following types of peripheral interrupts.
• Private peripheral interrupt (PPI) is a peripheral interrupt that is specific to a single
processor.
• Shared peripheral interrupt (SPI) is a peripheral interrupt that the distributor can route
to any of a specified combination of processors. These are wired interrupts coming
from various sources to the GIC.
Each peripheral interrupt is either edge-triggered or level-sensitive.
Send FeedbackZynq UltraScale+ Device TRM 309
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
Software-generated Interrupts
Software-generated interrupts (SGIs) are generated by software writing to a GICD_SGIR
register in the GIC. The system uses SGIs for inter-processor communication.
An SGI has edge-triggered properties. The software triggering of the interrupt is equivalent
to the edge transition of the interrupt request signal.
Virtualization Extensions
GIC virtualization extensions are used when an virtual SGI occurs. Management registers in
the GIC virtualization extensions enable the requesting processor to be reported to the
guest OS, as required by the GIC specifications. By writing to the management registers in
the GIC virtualization extensions, a hypervisor can generate a virtual interrupt that appears
to a virtual machine as an SGI.
Virtual Interrupt
A virtual interrupt targets a virtual machine running on a processor and is typically signaled
to the processor by the connected virtual CPU interface.
APU Interrupt Partitioning
This section covers the partitioning of the GICv2.
The distributor block performs interrupt prioritization and distribution to the CPU interface
blocks that connect to the processors in the system.
Each CPU interface block performs priority masking and preemption handling for a
connected processor in the system.
The GIC virtualization extensions add a virtual CPU interface for each processor in the
system. Each virtual CPU interface is partitioned into the following blocks.
• Virtual interface control: The main component of the virtual interface control block is
the GIC virtual interface control registers. These registers include a list of active and
pending virtual interrupts for the current virtual machine on the connected processor.
Typically, these registers are managed by the hypervisor that is running on that
processor.
• Virtual CPU interface: Each virtual CPU interface block provides physical signaling of
virtual interrupts to the connected processor. The Arm processor virtualization
extensions signal these interrupts to the current virtual machine on that processor. The
GIC virtual CPU interface registers, accessed by the virtual machine, provide interrupt
control and status information for the virtual interrupts.
Send FeedbackZynq UltraScale+ Device TRM 310
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
APU Interrupt Grouping and Virtualization
A virtual machine running on a processor communicates with a virtual CPU interface on the
GICv2 (Figure 13-3). The virtual machine receives virtual interrupts from this interface, and
cannot distinguish these interrupts from physical interrupts.
A hypervisor handles all IRQs, translating those destined for a virtual machine into virtual
interrupts, and, in conjunction with the GIC, manages the virtual interrupts and the
associated physical interrupts. It also uses the GIC virtual interface control registers to
manage the virtual CPU interface. As part of this control, the hypervisor updates the List
registers that are a subset of the GIC virtual interface control registers. In this way the
hypervisor and GIC together provide a virtual distributor that appears to a virtual machine
as the physical GIC distributor.
The GIC virtual CPU interface signals virtual interrupts to the virtual machine, subject to the
normal GIC handling and prioritization rules.
• Secure software assigns the following.
° Secure interrupts to group 0, signaled to the processor as FIQs
° Non-secure interrupts to group 1, signaled to the processor as IRQs.
• A hypervisor is used for the following.
° Implements a virtual distributor, using features of the virtualization extension on
the GIC. This virtual distributor can virtualize IRQ interrupts from the GIC as virtual
IRQ and virtual FIQ interrupts, which it routes to an appropriate virtual machine.
° Routes physical IRQs to hypervisor mode, so they can be serviced by the virtual
distributor.
When the GIC signals an IRQ to the processor, the interrupt is routed to hypervisor mode.
The hypervisor determines whether the interrupt is for itself or for a guest OS. If it is for a
guest OS it determines the following.
• The specific guest OS that must handle the interrupt.
• Whether that guest OS has configured the interrupt as an FIQ or as an IRQ
• The interrupt priority, based on the priority configuration by the target guest OS.
If the interrupt targets the current guest OS, the hypervisor updates the list registers, to add
the interrupt to the list of pending interrupts for the current virtual machine.
Send FeedbackZynq UltraScale+ Device TRM 311
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
Note: The APU GIC is physically located on the AXI interconnect as an FPD slave, but should only be
accessed by the APU MPCore. The FPD main interconnect switch can restrict access to the APU GIC.
However, a PL master can access the APU GIC through the S_AXI_ACP_FPD interface and cannot be
stopped by the FPD switch. The XMPU can be configured to block the S_AXI_ACP_FPD interface from
accessing the APU GIC.
X-Ref Target - Figure 13-3
Figure 13-3: APU with Interrupt Virtualization Block Diagram
MPSoC
GIC
Distributor
GICD_IGROUP
EnableGrp0
FIQEn==1
EnableGrp1
Guest OS 2
Processor
Hypervisor
Virtual Distributor
List Registers Register IRQ Assignment
Updates
EnableGrp0
FIQEn==1
EnableGrp1
Non-secure
System Software
Guest OS 1
Guest OS 0
Secure
Software
Secure Monitor
Hardware Interrupt
Group 0
Interrupt
Group 1
Interrupt
Group 0
Virtual
Interrupt
Virtual CPU Interface
Group 1
Virtual
Interrupt
IRQ
vIRQ
vFIQ
FIQ
CPU Interface
Maintenance
Interrupt
X15329-092816
Send FeedbackZynq UltraScale+ Device TRM 312
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
IPI Interrupts and Message Buffers
The heterogeneous multiprocessor system uses the inter-processor interrupt (IPI) structure
to exchange short interrupt-driven messages between processors in the system. The IPI
architecture allows the passing of messages across the system without the complications of
autonomous read-write transactions and polling inefficiency.
• Four channels assigned to target the PMU.
• Seven channels can be assigned to target RPU core 0, RPU core 1, the APU MPCore,
four processors in the PL, and four channels to the PMU (in addition to the dedicated
channels).
• Register access is restricted to a processor by the XPPU protection unit.
Note: The IPI channel registers can be owned by any of the masters except the interrupts for the
PMU channels are only routed to the PMU.
Processor communications include both an IPI interrupt structure and memory buffers to
exchange short private 32B messages between eight IPI agents — the PMU, RPU, APU, and
PL processors. Access to the interrupt registers and message buffers is protected by the
XPPU to give exclusive access to the AXI transactions of the agents.
In a typical situation, the sender writes a 32-byte request message and generates an
interrupt to the receiver. The receiver can write a response message and clear the interrupt
that is observed by the sender. The communications process uses both the IPI interrupt
structure and the message buffers. There are eleven interrupt channels and eight sets of
message buffers.
• The interrupt channels are as follows.
° Seven interrupts default to APU MPCore, RPU0, RPU1, and PL {0:3}, but can be
reprogrammed to any processor because they are distributed to all four system
interrupt controllers.
° Four interrupts are hardwired to the PMU interrupt controller, IPI channels {3:6}.
Send FeedbackZynq UltraScale+ Device TRM 313
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
• Message buffers provide exclusive communications between each sender and each
receiver.
° Seven sets of assignable message buffers.
° One set of buffers dedicated to the PMU.
° Each set has eight request and eight response buffers (16 buffers per set, 128 total
buffers).
The PMU special considerations are as follows.
• Four sets of IPI interrupt registers for one processor.
• The PMU IPI 0 interrupt instructs the PMU to enter sleep mode.
• One set of message buffers are used for all four PMU interrupts.
The IPI interrupts and message buffers are independent hardware functions that are
associated by software programming. There are default owners and an implied association
between the interrupt registers and message buffers. Only the PMU interrupts are fixed in
hardware.
The sender can post multiple interrupt requests and have different communication
protocols with each target. The assignment and use of the non-PMU interrupts and the
entire message passing architecture can be programmed as needed by the system
architecture. The reset default conditions and software conventions in the SDK define a
starting state for the system.
Send FeedbackZynq UltraScale+ Device TRM 314
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
Interrupt Architecture
The interrupt architecture includes eleven sets of registers with six registers per set. Each
set is divided between sending an interrupt (TRIG and OBS) and receiving an interrupt (ISR,
IMR, IER, and IDR). Access to each set of interrupt registers is protected by eight of the
64 KB apertures in the XPPU. Only eight apertures are needed because the four PMU
interrupt registers are all within one 64 KB address space.
To send an interrupt, the sender writes a 1 to the bit in its trigger register that corresponds
to the receiving master. The receiver sees the interrupt in its status register, ISR, in the bit
field that corresponds to the sender. The sender can observe the state of the interrupts that
it triggered to the receivers using its observation register (OBS). The receiver agent
processes interrupts in a normal manner. The registers and signal routings are shown in
Figure 13-4.
X-Ref Target - Figure 13-4
Figure 13-4: Sender-Receiver Interrupt Functions
Trigger Register (TRIG)
2 3
Write
Observation Register (OBS)
2 3
Read
Sender
Channel 8
8 Read status request.
Status/Clear Write 1 to clear.
Receiver
Channel 2
Mask 8
8
IPI IRQ Channel 2
(OR of all bits)
Enable
Disable
To mask
IPI IRQ signals are routed to RPU and APU GICs,
GIC Proxy, PL outputs, and PMU in interrupt controller.
Except PMU (0.3) IRQs are only routed to the PMU
interrupt controller in I/O module.
IPI CH 3 to 6 are hardware
assigned to the PMU.
Write 1 to enable.
Write 1 to disable.
Receiver
Channel 3
Observe
interrupt request status.
Set an
interrupt.
X19836-090717
Send FeedbackZynq UltraScale+ Device TRM 315
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
Interrupt Register Descriptions
Each processor is assigned to a set of six IPI registers divided into sending and receiving
interrupts. The IPI interrupt register functionality is provided in Table 13-2.
Interrupt Register Channels
Each interrupt channel has six registers. Two registers are for sending an interrupt and four
registers are for receiving an interrupt. The trigger and observation registers are used to
send and monitor interrupts. The status/clear, mask, disable, and enable registers are used
to receive an interrupt.
There are eleven sets of interrupt registers for use by any processor, except IPI channels
{3:6}, which are hardwired for the PMU. The default and hardwired channel assignments are
shown in Figure 13-5. Default channel assignments are defined in the AMD software and
supported by the master IDs configured in the XPPU after reset.
Table 13-2: IPI Interrupt Register Functionality
Channel
Activity Register Name Acronym
Bit Writes Bit Reads
Write a 1 Write a 0 Read a 1 Read a 0
Send
interrupt
Trigger TRIG Assert interrupt Ignored Write only
Observation OBS Read only Interrupt request
asserted.
Interrupt request
not asserted.
Receive
interrupt
Status and clear ISR Clear bit Ignored Interrupt request
asserted.
Interrupt request
not asserted.
Mask IMR Read only
IRQ not generated
if status bit is
asserted.
IRQ generated if
status bit is
asserted.
Mask enable IER Set IMR = 1 Ignored Write only
Mask disable IDR Set IMR = 0 Ignored Write only
Send FeedbackZynq UltraScale+ Device TRM 316
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
The non-PMU IRQ system interrupts are bused to four places, as follows.
Note: It is the responsibility of the individual masters to mask any unwanted IPIs in their own GIC.
• RPU GIC uses the GICv1.0 architecture and is controlled by the RPU.
• APU GIC uses the GICv2.0 architecture and is controlled by the APU.
• GIC proxy is an AMD architecture for the PMU external interrupt controller and is
controlled by the PMU.
• PL outputs include four signals from the PS to the PL.
The PMU IRQ signals are only routed to the PMU.
X-Ref Target - Figure 13-5
Figure 13-5: IPI Interrupt Channel Architecture
Channel0
Channel1
Channel2
PMU_0
PMU_1
PMU_2
PMU_3
Channel7
Channel8
Channel9
Channel10
Sender
Registers
* Trigger (TRIG)
* Observe (OBS)
XPPU 64KB
Aperture
Permissions
Channel0
Channel1
Channel2
PMU_0
PMU_1
PMU_2
PMU_3
Channel7
Channel8
Channel9
Channel10
IPI Channel
Assignments
APU MPCore
RPU0
RPU1
0
1
2
3
PL 0
PL 1
PL 2
PL 3
Receiver
Registers
*Status-clear (ISR)
* Mask (IMR)
* Enable (IER)
* Disable (IDR)
Channel0
Channel1
Channel2
PMU_0
PMU_1
PMU_2
PMU_3
Channel7
Channel8
Channel9
Channel10
IRQ Signal
Routing
All, GIC [67]
All, GIC [65]
All, GIC [66]
only, IPI0
only, IPI1
only, IPI2
only, IPI3
All, GIC [61]
All, GIC [62]
All, GIC [63]
All, GIC [64]
Default
Handwired
for PMU
Default
*RPU and APU GICs
* GIC proxy
* PL outputs
* PMU I/O module
Note: It is possible for a
processor to send an
interrupt to itself.
Interrupt
Routing
Channel0
Channel1
Channel2
PMU_0
PMU_1
PMU_2
PMU_3
Channel7
Channel8
Channel9
Channel10
X19837-090717
Send FeedbackZynq UltraScale+ Device TRM 317
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
Message Passing Architecture
The messaging system connects eight agents together in a mesh configuration. The PL is
represented by four agents, and the PMU is one agent. The message passing between
agents can be done exclusively between the sender and receiver using all 128 of the 32B
permission apertures in the XPPU.
To support message passing, the software in the two processors must pre-define the format
of the request and response message buffers. The buffer content does not affect the
hardware. The use of a message buffer is optional. Figure 13-6 shows the IPI message
passing architecture.
X-Ref Target - Figure 13-6
Figure 13-6: IPI Message Passing Architecture
Message
Buffers
Request
XPPU 32B
Permission
Apertures
Agents 1-8
Agent 1
Response
Read
Write
Request
Agent 2
Response
Read
Write
Request
Agent 8
Response
Read
Write
Write
Read
Write
Read
Write
Read
Agent as
Requester
Agent as
Responder
Note: It is possible for a
processor to exchange
messages with itself.
128 total buffers:
8 for sending, 8 for receiving,
2 way communication
X19838-090717
Send FeedbackZynq UltraScale+ Device TRM 318
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
Register and Buffer Summary
The IPI interrupt channels and message buffers are pre-defined and software associated as
described in Table 13-3.
Note: The software might reassign the interr/upt channels and message buffers except for the PMU
interrupts.
Programming
The communication channels between processors must be coordinated with an agreed
upon protocol and message format.
Generate an Interrupt
To generate an interrupt, the sender writes a 1 to a bit in its trigger (TRIG) register that
corresponds to the target receiver. It can verify that a bit is set in the receiver's status
register by reading its own OBS register. However, it cannot determine if the interrupt is
enabled to generate the IRQ interrupt signal.
Table 13-3: IPI Channel and Message Buffer Default Associations
Channel
Number
Default
Owner
IPI Interrupt Registers IPI Message Buffers
Name Base Address XPPU 64 KB
Aperture
SI Agent
Number Base Address XPPU 32B
Apertures
Channel 0 APU Channel0 0xFF30_0000 048 1 0xFF99_0400 256 - 271
Channel 1 RPU0 Channel1 0xFF31_0000 049 2 0xFF99-0000 272 - 287
Channel 2 RPU1 Channel2 0xFF32_0000 050 3 0xFF99_0200 288 - 303
Channel 3
PMU(1)
PMU_0(2) 0xFF33_0000
051 8 0xFF99_0E00 368 - 383
Channel 4 PMU_1 0xFF33_1000
Channel 5 PMU_2 0xFF33_2000
Channel 6 PMU_3 0xFF33_3000
Channel 7 PL 0 Channel7 0xFF34_0000 052 4 0xFF99_0600 304 - 319
Channel 8 PL 1 Channel8 0xFF35_0000 053 5 0xFF99_0800 320 - 335
Channel 9 PL 2 Channel9 0xFF36_0000 054 6 0xFF99_0A00 336 - 351
Channel 10 PL 3 Channel10 0xFF37_0000 055 7 0xFF99_0C00 352 - 367
Notes:
1. The PMU interrupts are hardwired because the PMU IRQ signals only go to the PMU interrupt.
2. The PMI IPI0 interrupt causes the PMU to enter sleep mode.
Send FeedbackZynq UltraScale+ Device TRM 319
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
Determine the Source of Interrupt
A processing unit reads its interrupt status (ISR) and mask (IMR) registers to determine the
source that caused the IRQ interrupt. Once serviced, the ISR can be cleared by writing the
data that was read from this register. The bits that were set are cleared while preserving any
bits that got set after the read took place, which helps to eliminate missed interrupts.
Send an IPI Communication
This section describes how to send an IPI communication.
1. Write a 32B request into the appropriate message buffer.
2. Write a 1 in the target receiver bit of its interrupt trigger register.
3. Optionally, verify that the interrupt is posted by reading its observation register.
4. Determine that the interrupt has been processed with one of the following steps.
a. Poll the observation register until the status bit is cleared indicating that the receiver
has processed the interrupt.
b. Receive an IPI interrupt from the sender.
The method to indicate when an interrupt has been processed must be pre-arranged
between the sender and receiver. The format of the message buffers must also be
pre-arranged.
Receive an IPI Communication
This section describes how to receive an IPI communication.
1. Prepare to receive a message request with one of the following steps.
a. Enable the interrupt from the sender using the IPI mask register, IMR, and in the
processor's interrupt controller by accessing GIC registers.
b. Poll the status register for bits being set.
2. When an interrupt is received, optionally write a 32B response into the appropriate
message buffer.
3. Signal to the sender that the interrupt has been processed with one of the following
steps.
a. Clear the status register.
b. Issue an IPI interrupt back to the sender.
Send FeedbackZynq UltraScale+ Device TRM 320
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
Interrupt Registers
There are several sets of interrupt registers and IPI message buffers that are memory
mapped.
• RPU GIC: Arm PL390 with GICv1 interrupt architecture.
• APU GIC: Arm GIC400 with GICv2 interrupt architecture.
• GIC proxy system interrupt controller and AMD PMU interrupt architecture.
• IPI interrupts and AMD processor communications architecture.
• IPI message buffers, 32B x 128 buffers starting at address 0xFF99_0000.
The interrupt register sets are summarized in Table 13-5.
GIC Proxy Interrupts
The GIC proxy interrupts are used by the PMU when the RPU and APU cannot service an
interrupt because the processor is powered-down.
The GIC proxy interrupts are listed in Table 13-4 and are controlled by the five sets of
interrupt registers in the LPD_GIC_PROXY register set: GICP{0:4}_IRQ_{TRIGGER, STATUS,
MASK, ENABLE, DISABLE}. The mask register bits are applied to the status register bits.
Interrupt Status Register
The bits in the GIC proxy status registers GICP{0:4}_IRQ_STATUS are sticky and remain
asserted after the source of the interrupt has deasserted its signal. The minimum interrupt
pulse width for detection is four clock periods of the GIC proxy unit, which is normally a
100 MHz clock resulting in a minimum 40 ns pulse width. A shorter pulse width might also
be detected. The status register bits are cleared by writing a 1 to them. The status register
shows the interrupt state before the mask is applied. This register can be polled to
determine if the event occurred or did not occur, irrespective of the state of the associated
mask bit. Software acknowledges the interrupt by clearing this register.
Interrupt Mask Register (IMR_REG)
The mask register is read-only. When a bit reads as a 1, it means an active interrupt from the
status register is masked and it does not propagate to the GICP_PMU_IRQ_STATUS register.
The default (reset) state is 1, implying all interrupts are masked.
Send FeedbackZynq UltraScale+ Device TRM 321
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
Interrupt Enable and Interrupt Disable Registers
There are separate write-only registers for enabling (GICPx_IRQ_ENABLE) and disabling
(GICPx_IRQ_DISABLE) a particular interrupt. This allows enabling/disabling on any single
interrupt without the need for a read-modify-write register operation.
Interrupts to PMU
The state of the GIC proxy interrupts after the interrupt mask are OR'ed together on a per
register basis to set bits in the LPD_SLCR.GICP_PMU_IRQ_STATUS register. For example, if
any unmasked interrupt in the LPD_GIC_PROXY.GICP0_IRQ_STATUS register is active, then
the LPD_SLCR.GICP_PMU_IRQ_STATUS [src0] bit is set by the interrupt hardware.
The PMU can read the GICP_PMU_IRQ_{STATUS, MASK} registers to determine which GIC
proxy register allowed the interrupt to propagate. Finally, the GIC proxy status and mask
registers that were determined to propagate the interrupt can be read to determine which
system element caused the interrupt.
CPU Private Peripheral Interrupts
The functionality of the RPU PPIs are described by the GICv1 architecture specification. This
is a subset of the APU PPI functionality that is described by the GICv2 specification.
Each CPU connects to a private set of peripheral interrupts. The list for the RPU is a subset
of the APU. The sensitivity type (edge or level) for PPIs are fixed and cannot be changed.
RPU Private Interrupts
The ICDICFR1 register is read-only, since it specifies the sensitivity types of all five PPIs.
The fast interrupt (FIQ) signal and the interrupt (IRQ) signal from the PL are inverted and
then sent to the interrupt controller. Consequently, they are active High at the PS-PL
interface, although the ICDICFR1 register reflects them as active Low level.
Send FeedbackZynq UltraScale+ Device TRM 322
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
APU Private Interrupts
Each APU core has a private set of peripheral interrupts routed from the CPU itself and the
PL. They are listed in Table 13-4.
GIC Address Map
The APU GIC's base address is configured by the APU MPCore pins (PERIPHBASE). The RPU
GIC's base address is aligned to the Cortex-R5F MPCore’s low-latency peripheral port (LLPP)
base-address.
The GIC-400 uses eight pages of 4 KB memory-mapped address-space. However, to support
a 64 KB page size (as required by SBSA v2), the GIC-400 address needs to be mapped such
that pages are 64 KB. For this, the AXI address is mapped to a GIC slave interface as
described in this equation.
AddressGIC400[14:0] = {AddressAXI[18:16], AddressAXI[11:0]}
Table 13-4: APU Private Peripheral Interrupts
Name Interrupt
ID Description
Virtual maintenance interrupt
25 Configurable event generated by virtual CPU interface to indicate
a situation that might require hypervisor action.
Hypervisor timer 26 Physical timer event in hypervisor mode, PPI5 (CNTHP IRQ).
Virtual timer 27 Virtual timer generated event, PPI4 (CNTV IRQ).
Legacy FIQ signal 28 FIQ signal from the PL.
Secure physical timer 29 Secure physical timer event, PPI1 (CNTPS IRQ).
Non-secure physical timer 30 Non-secure physical timer event, PPI2 (CNTPNS IRQ).
Legacy IRQ signal 31 IRQ signal from the PL.
Send FeedbackZynq UltraScale+ Device TRM 323
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
Register Overview
There are several interrupt register sets as shown in Table 13-5.
Table 13-5: Interrupt Register Overview
Starting
Address Register Set Count Description
RPU - Private CPU Bus for RPU MPCore
0xF900_0000 PL390.enable 1 Interrupt control register (ICDICR).
0xF900_0080 PL390.sgi_security_if_n 1 SGI interrupt security register (ICDISR).
0xF900_0084 PL390.spi_security 5 SPI interrupt security register (ICDISR).
0xF900_0104 PL390.spi_enable_set 5 SPI enable set register (ICDISER).
0xF900_0184 PL390.spi_enable_clr
5 SPI interrupt clear-enable registers
(ICDICER).
0xF900_0200 PL390.sgi_pending_set_if_n
1 SGI interrupt set-pending registers
(ICDISPR).
0xF900_0204 PL390.spi_pending_set
5 SPI interrupt set-pending registers
(ICDISPR).
0xF900_0280 PL390.sgi_pending_clr_if_n 1 SGI pending clear register (ICDICPR).
0xF900_0284 PL390.spi_pending_clr 5 SPI pending clear register (ICDICPR).
0xF900_0300 PL390.sgi_active_if_n 1 SGI active bit registers (ICDABR).
0xF900_0304 PL390.spi_active 5 SPI active bit registers (ICDABR).
0xF900_0400 PL390.priority_sgi_if_n 16 SGI interrupt priority registers (ICDIPR).
0xF900_0420 PL390.priority_spi 160 SPI interrupt priority registers (ICDIPR).
0xF900_0820 PL390.targets_spi 160 SPI target register interrupt (ICDIPTR).
0xF900_0C08 PL390.spi_config
5 SPI interrupt configuration register
Interrupt (ICDICR).
APU - AXI Interconnect with Access Restricted to APU MPCore
0xF901_0000 GIC400.GICD 180 Display controller.
0xF902_0000 GIC400.GICC 15 CPU interface.
0xF904_0000 GIC400.GICH 99 Hypervisor.
0xF906_0000 GIC400.GICV 14 Virtual machine.
GIC Proxy - LPD Slave
0xFF41_8000
LPD_GIC_PROXY.GICP{0:5}_
{STATUS, MASK, ENABLE, DISPLAY,
TRIGGER}
30 System interrupt control registers.
0xFF41_80A0
LPD_GIC_PROXY.GICP_IRQ_
{STATUS, MASK, ENABLE, DISPLAY,
TRIGGER}
5 OR'ed interrupts control registers.
Send FeedbackZynq UltraScale+ Device TRM 324
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
Programming Examples
• For Programming of the GICV1, refer to the Arm® Generic Interrupt Controller
Architecture version 1.0.
• For Programming of the GICV2, refer to the Arm® Generic Interrupt Controller
Architecture version 2.0.
Clearing Pending Interrupts from the APU GICv2
The GICv2 gets reset based on reset of the interconnect and does not have a soft reset bit.
These steps ensure that all pending interrupts are cleared after the CPU comes back up
from a reset:
1. Write the value FFFF_FFFFh into the GICD_ICENABLERx register.
2. Write the value FFFF_FFFFh into the GICD_ICPENDRx register.
3. Write the value FFFF_FFFFh into the GICD_ICACTIVERx register.
4. Write the value FFFF_FFFFh into the GICD_CPENDSGIRx register.
IPI - LPD Slave
0xFF30_0000 IPI.CH0_{TRIG, OBS, ISR, IMR, IER, IDR}
IPI.CH1_{TRIG, OBS, ISR, IMR, IER, IDR}
IPI.CH2_{TRIG, OBS, ISR, IMR, IER, IDR}
IPI.PMU_0_{TRIG, OBS, ISR, IMR, IER, IDR}
IPI.PMU_1_{TRIG, OBS, ISR, IMR, IER, IDR}
IPI.PMU_2_{TRIG, OBS, ISR, IMR, IER, IDR}
IPI.PMU_3_{TRIG, OBS, ISR, IMR, IER, IDR}
IPI.CH7_{TRIG, OBS, ISR, IMR, IER, IDR}
IPI.CH8_{TRIG, OBS, ISR, IMR, IER, IDR}
IPI.CH9_{TRIG, OBS, ISR, IMR, IER, IDR}
IPI.CH10_{TRIG, OBS, ISR, IMR, IER, IDR}
60
Inter-processor interrupts:
trigger, observation, status and clear,
mask, mask enable, mask disable.
IPI_CTRL 1 SLVERR bus error enable control.
IPI_{ISR, IMR, IER, IDR}
4 SLVERR interrupt status, mask, mask
enable/disable.
0xFF38_0030 SAFETY_CHK
1 Safety endpoint connectivity check
register, no effect on IPI operations.
Table 13-5: Interrupt Register Overview (Cont’d)
Starting
Address Register Set Count Description
Send FeedbackZynq UltraScale+ Device TRM 325
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
The following is sample FSBL code for clearing the pending interrupts from the APU GICv2.
XFsbl_Printf (DEBUG_GENERAL, "Clear pending interrupts from APU GIC\n\r");
for (i = 0; i < 6; i++) {
Xil_Out32 (GICD_BASEADDR + 0x180 + 4*i, 0xffffffff); // GICD_ICENABLERx (x= 0 to 5)
Xil_Out32 (GICD_BASEADDR + 0x280 + 4*i, 0xffffffff); // GICD_ICPENDRx (x= 0 to 5)
Xil_Out32 (GICD_BASEADDR + 0x380 + 4*i, 0xffffffff); // GICD_ICACTIVERx (x= 0 to 5)
}
for (i = 0; i < 4; i++) {
Xil_Out32 (GICD_BASEADDR + 0xF10 + 4*i, 0xffffffff); // GICD_CPENDSGIRx (x= 0 to 3)
}
Programming Model IPI
This section describes programming the interrupts.
Example: Initiate an IPI
1. Initiator software writes a request message to memory.
2. Initiator writes a 1 to its Trigger register for the target processor.
3. Initiator may pole its Observation register or wait for an IPI response interrupt from the
target.
4. After the target has indicated it has responded to the interrupt, the initiator can read
the response message in memory. This is in a pre-defined format to a pre-defined
memory location.
Example: Receive an IPI
1. The target must enable interrupts to receive an IRQ to its interrupt controller. This is
done using the Mask register.
2. The target IRQ handler reads its status (ISR) and mask (IMR) registers to determine the
identity of the initiator.
3. The target reads the Request Message written by the initiator. It processes it and
provides a Response Message. The messages are in a pre-determined format in a
pre-determined place in memory.
4. The target clears the IRQ in the IPI and optionally sends an IPI response to the target.
Send FeedbackZynq UltraScale+ Device TRM 326
UG1085 (v2.5) March 21, 2025
Chapter 13: Interrupts
Enable the Interrupt
To enable the interrupt, write a 1 to the bit corresponding to the processing unit whose
interrupt needs to be enabled in the *_IER register.
Disable the Interrupt
To disable the interrupt, write a 1 to the bit corresponding to the processing unit whose
interrupt needs to be disabled in the *_IDR register.